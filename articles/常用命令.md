#### 常用命令
##### 压缩
+ zip压缩时保留符号链接: 使用'-y'选项 `zip -ry xxx.zip <dir>`
+ tar压缩文件或目录: `tar -czf xxx.tar.gz <path>`

##### 挂载
+ 将'/data/share'挂载到'/share': `mount /data/share /share`
+ 显示挂载信息: `mount -l`
+ 取消'/share'目录的挂载: `unmount /share`
+ 挂载proc文件系统: `mount -t proc /proc xxx/proc`
+ 挂载sysfs文件系统: `mount -t sysfs /sys xxx/sys`

##### 查看/统计信息
+ 查看cpu信息: `cat /proc/cpuinfo`
+ 查看cpu数量: `cat /proc/cpuinfo | grep name | wc -l`
+ 查看系统ld链接器链接目录(可在其上添加自己的库目录): `cat /etc/ld.so.conf`
+ 查看某目录下文件目录的大小: `du <dir> --max-depth=1 -h`
+ 查看磁盘信息及磁盘使用量: `df -h`
+ 查看系统内核参数: `sysctl -a`
+ 查看程序的缺页中断次数:
  ```bash
  # major表示读磁盘的中断, COMMON指进程的comm
  ps -o majflt,minflt -C <COMMAND>
  # 当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：
  #   1、检查要访问的虚拟地址是否合法
  #   2、查找/分配一个物理页
  #   3、填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）
  #   4、建立映射关系（虚拟地址到物理地址）
  # 重新执行发生缺页中断的那条指令
  # 如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。
  ```
+ Linux查看当前内核的编译参数:
  ```bash
  cat /usr/src/kernels/`uname -r`/.config
  # 或者
  cat /boot/config-$(uname -r)
  # 参考: https://www.cnblogs.com/linengier/p/9956517.html
  ```
+ 查看内核中的函数符号及其地址: `cat /proc/kallsyms`
+ 查看系统架构对应的预定义宏: [predef-wiki-architectures](https://sourceforge.net/p/predef/wiki/Architectures/)
  ```
  alpha
  arc
  arm
  aarch64_be（arm64）
  aarch64（arm64）
  armv8b（arm64兼容）
  armv8l（arm64兼容）
  blackfin
  c6x
  cris
  frv
  h8300
  hexagon
  ia64
  m32r
  m68k
  metag
  microblaze
  mips （本地或兼容）
  mips64（mips）
  mn10300
  nios2
  openrisc
  parisc （本地或兼容）
  parisc64（parisc）
  ppc（powerpc本地或兼容）
  ppc64（powerpc）
  ppcle（powerpc本地或兼容）
  ppc64le（powerpc）
  s390（s390x兼容）
  s390x
  score
  sh
  sh64（sh）
  sparc （本地或兼容）
  sparc64（sparc）
  tile
  unicore32
  i386（x86）
  i686（x86兼容）
  x86_64（x64）
  xtensa
  ```

##### 其它
+ 生成随机文件: `dd if=/dev/urandom of=/data/share/test.file count=1024 bs=1024`, 生成1024*1024大小的文件，即1M，从随机生成器中取的，因此是随机内容的文件
+ 设置系统代理: 
  ```bash
  export http_proxy=http://<ip>:<port>
  export https_proxy=https://<ip>:<port>
  ```
+ 使用alias，提供代理启停命令
  ``` bash
  alias enable-proxy="export http_proxy=http://<ip>:<port>;export https_proxy=http://<ip>:<port>;"
  alias disable-proxy="export http_proxy=;export https_proxy=;"
  ```    
+ 指定预加载动态库: `export LD_PRELOAD=<so_filepath>`
+ curl发送http-post请求: 
  ```bash 
  curl -XPOST http://<domain>/api/login -d '{"username":"xxx","password":"xxx"}'
  ```
+ pip加速:
  ```bash
  pip install xxxx -i  https://pypi.douban.com/simple/ --trusted-host pypi.douban.com
  ```
+ python启动简单的http服务器:
  ```bash
  # python2使用
  python2 -m SimpleHTTPServer
  # python3使用
  python3 -m http.server
  ```
+ 设置初次ssh登录linux的时候无需yes确认登陆
  ```bash
  echo "StrictHostKeyChecking no" >>~/.ssh/config
  # 此时，ssh登录远程任意机器都不会问你yes or no.
  ```

##### 需注意的问题
###### 通配符
```bash
ls path/* # 匹配的是非隐藏目录和非隐藏文件，用于cp的时候也一样，因此就不会复制隐藏文件和目录
cp -r path/* path_to/ # 不复制隐藏文件和目录
cp -r path path_to # 要复制隐藏文件和目录
```

#### 程序编译相关
##### google-sanitizers
使用该工具集可在编译时对代码存在的问题进行分析，主要分为:
+ `AddressSanitizer (ASan)`: detects addressability issues
+ `LeakSanitizer (LSan)`: detects memory leaks
+ `ThreadSanitizer (TSan)`: detects data races and deadlocks
+ `UndefinedBehaviorSanitizer (UBSsan)`: detects undefined behaviors.
+ `MemorySanitizer (MSan)`: detects use of uninitialized memory

目前该工具已经集成在了编译器支持里，clang/gcc/msvc都可用，linux下直接添加CXXFLAGS: `-g -fsanitize=[sanitizer_name]`即可使用，其中sanitizer_name对应:
+ `address` for AddressSanitizer
+ `leak` for LeakSanitizer
+ `thread` for ThreadSanitizer
+ `undefined` for UndefinedBehaviorSanitizer (other options are also available, see the UBSan section)
+ `memory` for MemorySanitizer

参考链接: 
1. [google/sanitizers - github](https://github.com/google/sanitizers)
2. [clion-google-sanitizers-compile-flags - jetbrains](https://www.jetbrains.com/help/clion/2021.1/google-sanitizers.html#CompilerFlags)
3. [编译器自带的调试神器sanitizers - 知乎](https://zhuanlan.zhihu.com/p/257939964)
4. [msvc-sanitizers-support - MSDN](https://devblogs.microsoft.com/cppblog/asan-for-windows-x64-and-debug-build-support/)
##### 减小程序大小
1. gcc编译隐藏符号
    ```bash
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -ffunction-sections -fdata-sections -fvisibility=hidden")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -ffunction-sections -fdata-sections -fvisibility=hidden")
    ```
2. gcc链接选项，不链接未使用的代码
    ```bash
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wl,-Map=object.map,--cref,--gc-section")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wl,-Map=object.map,--cref,--gc-section")
    ```
3. strip去除不必要信息
    ```bash
    # 去除不必要的信息
    strip xxx --strip-unneeded
    # 去除调试信息
    strip xxx -g
    # 编译的程序可以使用`strip -g`去除调试信息，然后保留未去除的版本，发布去除后的版本
    # strip过的版本生成coredump后，使用原始版本即可查看coredump详细信息
    ```
4. 使用gcc优化选项
   + `-O2`(推荐)
   + `-Os`(减少代码大小)，但不推荐
##### gcc相关文档
1. [gcc -O优化相关选项文档](https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Optimize-Options.html)
2. [gcc各版本命令行及选项文档](https://gcc.gnu.org/onlinedocs/)


#### 程序性能分析
##### valgrind
+ valgrind安装: `yum install valgrind`
+ 检查内存泄漏
  ```bash
  valgrind --leak-check=full --show-reachable=yes --trace-children=yes CMD [ARGS]
  ```
+ 查看函数调用关系
  ```bash
  # 生成调用关系数据文件callgrind.out.[PID]
  valgrind --tool=callgrind CMD [ARGS] 
  # 文件左边第一列数据是指令数
  callgrind_annotate --auto=yes callgrind.out.[PID] >call_log.auto_yes.txt
  callgrind_annotate --tree=both callgrind.out.[PID] >call_log.tree_both.txt
  callgrind_annotate --inclusive=yes callgrind.out.[PID] >call_log.inc_yes.txt
  ```
+ [valgrind-manual(官方文档)](https://www.valgrind.org/docs/manual/manual-core.html#manual-core.xtree)
##### Perf Tool
+ perf tool安装: `yum install perf`
+ 实时查看指定pid的进程函数调用
  ```bash
  # dwarf是通过gcc -g编译选项添加的调试信息来记录的，因此需要分析的程序应该以'-g'编译
  perf top -p 9450 --call-graph dwarf
  # 记录程序运行的调用信息,默认生成perf.data
  perf record CMD [ARGS]
  # 也可使用-p指定pid，记录运行中的程序信息
  perf record -p <PID>
  # 生成报告，默认读取perf.data
  perf report                         
  ```
+ 生成程序函数调用火焰图
  ```bash
  # 安装绘制火焰图的工具 FlameGraph
  git clone https://github.com/brendangregg/FlameGraph.git
  # -g 记录堆栈信息 -e 指定事件(此处是cpu时钟事件)
  perf record -e cpu-clock -g -p PID
  perf script -i perf.data &> perf.unflod
  # 调用工具分析堆栈信息生成函数调用火焰图
  ./FlameGraph/stackcollapse-perf.pl perf.unflod &> perf.floded
  ./FlameGraph/flamegraph.pl perf.floded > perf.svg
  ```
+ 写个简单的脚本，实现指定pid和记录时间t，生成对应进程时间t内的函数调用火焰图
  ```bash
  #!/bin/sh
  time_out=$1 # 指定记录时间
  pid=$2      # 指定pid

  if [ -d data ]; then
      rm -rf data/perf.*
  else
      mkdir data
  fi

  # -g 记录堆栈信息 -e 指定事件(此处是cpu时钟事件)
  timeout $time_out perf record -e cpu-clock -g -p $pid -o data/perf.data

  perf script -i data/perf.data &> data/perf.unflod

  ./FlameGraph/stackcollapse-perf.pl data/perf.unflod &> data/perf.floded

  ./FlameGraph/flamegraph.pl data/perf.floded > data/perf.svg
  ```

#### 环境搭建/工具安装

##### git安装
```bash
# 安装编译环境
sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel 
wget https://github.com/git/git/archive/v2.24.0.tar.gz
make prefix=/usr/local/git all
make prefix=/usr/local/git install
vim /etc/profile 
export PATH=$PATH:/usr/local/git/bin # 添加到环境变量
source /etc/profile # 刷新配置
```
##### 7z
+ 7z安装: `yum install p7zip p7zip-plugins`

##### centos7安装多个版本gcc并切换使用
```bash
# 作者：weaponxx
# 链接：https://www.jianshu.com/p/427cee7a5576

yum install centos-release-scl
yum install scl-utils
# 查询软件集合
yum list all --enablerepo='centos-sclo-rh' | grep devtoolset
# 安装gcc 7 版本
yum install devtoolset-7-toolchain
# 列出所有软件
scl --list
# 切换软件环境
scl enable devtoolset-7 bash
# 退出当前环境
exit
```

##### zsh安装
1. 安装zsh
    ```bash
    sudo yum -y install zsh
    sudo apt-get -y install zsh
    ```
2. 将zsh替换为默认shell: `chsh -s /bin/zsh`
3. 安装zsh配置，这一步需要使用git
    ```bash
    # 安装git
    sudo yum -y install git
    # 安装oh-my-zsh
    sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
    ```
4. 修改配置`vi ~/.zshrc`，这一步是修改终端主题，纯凭个人喜好: `ZSH_THEME="robbyrussell"` ==> `ZSH_THEME="bira"`
5. 主题推荐(powerlevel10k)
6. 自动补全:
    + 下载zsh-autosuggestions自动补全插件到.oh-my-zsh的插件目录
        ```bash
        git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
        ```
	+ 编辑.zshrc文件，找到plugins=(git)这一行，如果没有添加。更改为: `plugins=(git zsh-autosuggestions)`

##### python虚拟环境安装
```bash
# 安装py虚拟环境
pip install virtualenv 
# 创建python版本的venv, dir即指定生成的venv目录
python -m venv <dir> 
# 进入创建好的虚拟环境目录
cd <dir>/Scripts/ 或者 cd <dir>/bin/
# 激活环境
./activate
```

##### pip安装
```bash
curl -O https://bootstrap.pypa.io/pip/2.7/get-pip.py
# 使用python执行该命令，使用国内豆瓣源，下载速度比较快
python get-pip.py -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
```

##### linux驱动开发包安装
+ opensuse: 
  ```bash
  # 安装4.4.27-2-default内核开发包
  zypper install kernel-default-devel=4.4.27-2
  ```
+ centos:
  ```bash
  # 安装最新内核开发包
  yum install kernel-devel
  yum install kernel-headers 
  ```
  centos上只能装最新的内核开发包，如果想安装的驱动内核开发包不是最新，则需要在网上下载对应的rpm包，下载完成后使用`rpm -ivh kernel-devel-xxx.rpm`和`rpm -ivh kernel-headers-xxx.rpm`进行安装`

##### clang-format安装
1. 安装：`yum install clang`
2. 格式化：`clang-format -style=llvm main.cpp`  
   直接在源文件上格式化：`clang-format -style=llvm -i main.cpp`
3. 格式化文件夹中所有文件：`find <path> -name "*.cpp" | xargs clang-format -style=llvm -i`
4. 输出配置文件：`clang-format -style=llvm -dump-config >.clang-format`
5. 指定配置文件进行格式化：`clang-format -style=file main.cpp`, file即表示读取当前目录的.clang-format文件
6. 可以用注释指示clang不要format某些行：
    ```cpp
    // clang-format off
      unformated code here
      ...
    // clang-format on
    ```

